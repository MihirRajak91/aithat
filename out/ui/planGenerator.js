"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlanGenerator = void 0;
const vscode = __importStar(require("vscode"));
const ollama_1 = require("../llm/ollama");
const contextBuilder_1 = require("../contextBuilder");
class PlanGenerator {
    constructor() {
        this.contextBuilder = new contextBuilder_1.ContextBuilder();
    }
    async generatePlan(ticket) {
        try {
            // Show progress
            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Generating implementation plan...',
                cancellable: false
            }, async (progress) => {
                progress.report({ message: 'Building workspace context...' });
                // Build workspace context
                const context = await this.contextBuilder.buildContext();
                progress.report({ message: 'Generating plan with AI...' });
                // Initialize Ollama provider (local AI)
                const ollamaProvider = new ollama_1.OllamaProvider({
                    model: 'llama2:13b'
                });
                // Format prompt
                const prompt = this.formatPrompt(ticket, context);
                // Generate plan
                const response = await ollamaProvider.generatePlan(prompt);
                progress.report({ message: 'Displaying plan...' });
                // Display the plan
                await this.displayPlan(ticket, response.content);
            });
        }
        catch (error) {
            console.error('Error generating plan:', error);
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            await vscode.window.showErrorMessage(`Failed to generate plan: ${errorMessage}`);
        }
    }
    formatPrompt(ticket, context) {
        return `Ticket: ${ticket.key} â€“ ${ticket.summary}
${ticket.description}
---  
Workspace context:
${context}
---  
Return a concise, numbered checklist to implement this ticket. Include specific steps, file modifications, and any new files that need to be created.`;
    }
    async displayPlan(ticket, planContent) {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const fileName = `plan-${ticket.key}-${timestamp}.md`;
        const fullContent = `# Implementation Plan for ${ticket.key}

**Ticket:** ${ticket.key} - ${ticket.summary}
**Generated:** ${new Date().toLocaleString()}
**Provider:** ${ticket.provider}

## Plan

${planContent}

---
*Generated by AI Plan VS Code Extension*
`;
        // Create and open the document
        const document = await vscode.workspace.openTextDocument({
            content: fullContent,
            language: 'markdown'
        });
        const editor = await vscode.window.showTextDocument(document);
        // Show success message
        await vscode.window.showInformationMessage(`Plan generated for ${ticket.key}!`);
    }
    async selectLLMProvider() {
        const providers = [
            { label: 'Ollama (Local)', value: 'ollama' },
            { label: 'OpenRouter (Cloud)', value: 'openrouter' }
        ];
        const selected = await vscode.window.showQuickPick(providers, {
            placeHolder: 'Select AI provider for plan generation...'
        });
        return selected?.value || 'ollama';
    }
    async configureLLMProvider(provider) {
        if (provider === 'ollama') {
            // Check if Ollama is running
            const ollamaProvider = new ollama_1.OllamaProvider({});
            const isValid = await ollamaProvider.validateConfig();
            if (!isValid) {
                await vscode.window.showErrorMessage('Ollama is not running or not accessible. Please start Ollama and ensure it\'s running on localhost:11434');
                return null;
            }
            return { type: 'ollama', model: 'llama2:13b' };
        }
        // For OpenRouter, we would prompt for API key
        if (provider === 'openrouter') {
            const apiKey = await vscode.window.showInputBox({
                prompt: 'Enter your OpenRouter API key',
                password: true
            });
            if (!apiKey) {
                return null;
            }
            return { type: 'openrouter', apiKey };
        }
        return null;
    }
}
exports.PlanGenerator = PlanGenerator;
//# sourceMappingURL=planGenerator.js.map